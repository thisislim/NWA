from tqdm import tqdm
from multiprocessing import Pool
from functools import partial

import Levenshtein
import numpy as np

DNA_ALPHABET = {
    "<unk>": 0, 
    "<pad>": 1, 
    "<sos>": 2,
    "<eos>": 3, 
    'A': 4,
    'C': 5,
    'G': 6,
    'T': 7
}

DNA_itos_ALPHABET = {
    0: "<unk>", 
    1: "<pad>", 
    2: "<sos>",  
    3: "<eos>", 
    4: "A", 
    5: "C", 
    6: "G", 
    7: "T"
}


def string_to_index(s, length=None, alphabet=DNA_ALPHABET):
    
    L = []
    L.append(alphabet["<sos>"])

    for i in range(length if length is not None else len(s)):

        if i < len(s):
            L.append(alphabet[s[i]])

        elif i == len(s):
            L.append(alphabet["<eos>"])

        elif i > len(s):
            L.append(alphabet["<pad>"])
            
        else:
            L.append(alphabet["<unk>"])
    
    return L

def index_to_string(seq, length=None, alphabet=DNA_itos_ALPHABET):
    S = []

    for i in range(length if length is not None else len(seq)):
        if alphabet[seq[i]] != "<pad>":
            S.append(alphabet[seq[i]])
        
    return S

def compute_ed_matrix(A, B, distance=Levenshtein.distance):
    return np.array([[distance(a, b) for b in B] for a in A])

def compute_ed_matrix_row(args, distance=Levenshtein.distance):
    a, B = args
    return [distance(a, b) for b in B]

def compute_ed_matrix_multiprocess(A, B, nthreads, distance=Levenshtein.distance):
    with Pool(nthreads) as p:
        distance_matrix = list(
            tqdm(
                p.imap(partial(compute_ed_matrix_row, distance=distance), zip(A, [B for _ in A])),
                total=len(A), 
                desc="Edit Distance matrix {}x{}".format(len(A), len(B)),
            ))
        return np.array(distance_matrix)

def compute_ed_matrix_mp_mute(A, B, nthreads, distance=Levenshtein.distance):
    with Pool(nthreads) as p:
        distance_matrix = list(
            p.imap(partial(compute_ed_matrix_row, distance=distance), zip(A, [B for _ in A]))
        )
    return np.array(distance_matrix)
    
def generate_edop(seq_len, num_edops, alphabets="ACGT"):
    """
    return: list of tuples
    generates edit distance operations
    ("option", source_index, alphabets_index)
    if option == "delete",  alphabets_index is a dummy value
    """
    alphabets_len = len(alphabets)
    options = ("insert", "delete", "replace")
    ops = []

    for _ in range(num_edops):
        option_idx = np.random.randint(0, 3)
        op = (options[option_idx], np.random.randint(0, seq_len), np.random.randint(0, alphabets_len))
        ops.append(op)
    return ops

def mutate_sequence(seq, num_edops, alphabets="ACGT"):
    """
    input: string, alphabets, max_ed(maximum edit distance)
    return: augmented string of input
    apply edit distance operation generated by edop_generator()
    """
    seq_len = len(seq)
    ops = generate_edop(seq_len, num_edops, alphabets)

    for op in ops:
        seq_idx = op[1]
        alphabet_idx = op[2]
        if op[0] == 'insert':
            seq = seq[:seq_idx] + alphabets[alphabet_idx] + seq[seq_idx:]

        elif op[0] == 'replace':
            seq = seq[:seq_idx] + alphabets[alphabet_idx] + seq[seq_idx+1:]

        elif op[0] == 'delete':
            if seq_idx > len(seq)-1:
                seq = seq[:-1]
                
            else: 
                seq = seq[:seq_idx] + seq[seq_idx+1:]

    return seq

